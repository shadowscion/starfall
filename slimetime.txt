--@name slimetime
--@author
--@shared

if SERVER then
    ---------------------------------------------------------------
    local pos, ang = localToWorld(Vector(0, 0, 54), Angle(90, math.round((owner():getPos() - chip():getPos()):getAngle().y/90)*90, 0), chip():getPos(), chip():getAngles())
    prop.createComponent(pos, ang, "starfall_screen", "models/hunter/plates/plate2x2.mdl", true):linkComponent(chip())


    ---------------------------------------------------------------
    ---- SERVERSIDE NETWORKING
    local gamesList = {}

    local debug = false
    local debugMsg = function(player, ...)
        print(Color(255, 0, 0), "Server-> ", Color(255, 251, 137), player .. "-> ", Color(255, 255, 255), ...)
    end

    local function getGameTable(ply)
        if not ply then
            return
        end
        if not gamesList[ply] then
            return
        end
        return gamesList[ply]
    end

    local function syncGamesList()
        net.start("syncGamesList")
        local count = table.count(gamesList)
        net.writeUInt(count, 8)
        for ply, _ in pairs(gamesList) do
            net.writeEntity(ply)
        end
        net.send()
    end

    net.receive("newgame", function(len, ply)
        if debug then debugMsg(ply:getName(), "newgame") end
        gamesList[ply] = {
            spectators = {}
        }
        syncGamesList()
    end)

    net.receive("endgame", function(len, ply)
        if gamesList[ply] then
            if debug then debugMsg(ply:getName(), "endgame") end
            if #gamesList[ply].spectators > 0 then
                net.start("endgame")
                net.send(gamesList[ply].spectators)
            end
            gamesList[ply] = nil
        end
        syncGamesList()
    end)

    hook.add("PlayerDisconnected", "", function(ply)
        if gamesList[ply] then
            if debug then debugMsg(ply:getName(), "endgame") end
            if #gamesList[ply].spectators > 0 then
                net.start("endgame")
                net.send(gamesList[ply].spectators)
            end
            gamesList[ply] = nil
        end
        syncGamesList()
    end)

    net.receive("newstream", function(len, viewer)
        local streamer = net.readEntity()
        if not streamer or not gamesList[streamer] then
            return
        end
        table.insert(gamesList[streamer].spectators, viewer)
        net.start("newstream")
        net.writeEntity(streamer)
        net.send(viewer)
    end)

    net.receive("endstream", function(len, viewer)
        local streamer = net.readEntity()
        if not streamer or not gamesList[streamer] then
            return
        end
        for i, ply in ipairs(gamesList[streamer].spectators) do
            if ply == viewer then
                table.remove(gamesList[streamer].spectators, i)
                break
            end
        end
    end)

    net.receive("syncDir", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local direction = net.readUInt(8)
        if debug then debugMsg(ply:getName(), "syncDir", direction) end
        if not direction then
            return
        end
        tbl.direction = math.clamp(direction, 1, 4)
        if #tbl.spectators > 0 then
            net.start("syncDir")
            net.writeUInt(tbl.direction, 8)
            net.send(tbl.spectators)
        end
    end)

    net.receive("syncPos", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local x = net.readUInt(8)
        local y = net.readUInt(8)
        if debug then debugMsg(ply:getName(), "syncPos", x, y) end
        if not x or not y then
            return
        end
        tbl.x = math.clamp(x, 7, 10)
        tbl.y = math.clamp(y, 7, 10)
        if #tbl.spectators > 0 then
            net.start("syncPos")
            net.writeUInt(tbl.x, 8)
            net.writeUInt(tbl.y, 8)
            net.send(tbl.spectators)
        end
    end)

    net.receive("syncCol", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local color = net.readUInt(8)
        if debug then debugMsg(ply:getName(), "syncCol", col) end
        if not color then
            return
        end
        tbl.color = math.clamp(color, 1, 4)
        if #tbl.spectators > 0 then
            net.start("syncCol")
            net.writeUInt(tbl.color, 8)
            net.send(tbl.spectators)
        end
    end)

    net.receive("syncScore", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local score = net.readUInt(32)
        if debug then debugMsg(ply:getName(), "syncScore", score) end
        if not score then
            return
        end
        tbl.score = math.clamp(score, 1, 4)
        if #tbl.spectators > 0 then
            net.start("syncScore")
            net.writeUInt(tbl.score, 32)
            net.send(tbl.spectators)
        end
    end)

    net.receive("syncBoard", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local board = net.readString()
        if debug then debugMsg(ply:getName(), "syncBoard") end
        if not board or #board ~= 256 then
            return
        end
        tbl.board = board
        if #tbl.spectators > 0 then
            net.start("syncBoard")
            net.writeString(tbl.board)
            net.send(tbl.spectators)
        end
    end)

    net.receive("syncAttack", function(len, ply)
        local tbl = getGameTable(ply)
        if not tbl then
            return
        end
        local board = net.readString()
        if debug then debugMsg(ply:getName(), "syncAttack") end
        if not board or #board ~= 256 then
            return
        end
        tbl.board = board
        if #tbl.spectators > 0 then
            net.start("syncAttack")
            net.writeString(tbl.board)
            net.send(tbl.spectators)
        end
    end)

    return
end

---------------------------------------------------------------
local function getIndex(x, y)
    return x + (y - 1)*16
end

local function getX(index)
    return math.floor((index - 1) % 16) + 1
end

local function getY(index)
    return math.floor((index - 1) / 16) + 1
end

local function inrange(n, min, max)
    return n >= min and n <= max
end

local function outCubic(t, b, c, d)
    return c * (math.pow(t / d - 1, 3) + 1) + b
end


---------------------------------------------------------------
---- INIT
local cursor = { x = 0, y = 0, onScreen = false }
function cursor:update()
    local cx, cy = render.cursorPos()
    self.x = cx or -1
    self.y = cy or -1
    if self.x == -1 or self.y == -1 then self.onScreen = false else self.onScreen = true end
end

local MENU = {}
render.createRenderTarget("menuRT")

local GAME = {
    screenRefresh = { background = true, foreground = true },
}
render.createRenderTarget("backgroundRT")
render.createRenderTarget("foregroundRT")
render.createRenderTarget("overlayRT")

---------------------------------------------------------------
function GAME:initialize(fps)
    self:resetScreen(fps)
    self.isInitialized = true
end


---------------------------------------------------------------
function GAME:resetScreen(fps)
    self.fps = fps or 60
    self.deltatime = 1 / self.fps
    self.systime = timer.systime()
    self.gametick = 0
    self.acctime = 0
    for rkey, rbool in pairs(self.screenRefresh) do
        self.screenRefresh[rkey] = true
    end
end


---------------------------------------------------------------
function GAME:render()
    if not self.isInitialized then
        self:initialize()
        return
    end
    if not self.focus then
        return
    end
    if self.onRender then self:onRender() end
end


---------------------------------------------------------------
function GAME:think()
    if not self.isInitialized then
        self:initialize()
        return
    end
    if not self.focus then
        return
    end
    local now = timer.systime()
    self.acctime = self.acctime + now - self.systime
    while self.acctime > self.deltatime do
        if self.onThink then
            self:onThink(self.deltatime, self.gametick)
        end
        self.gametick = self.gametick + 1
        self.acctime = self.acctime - self.deltatime
    end
    self.systime = now
end


---------------------------------------------------------------
function GAME:onThink(dt, tick)
    if self.gameover then
        return
    end

    if self.isDummy then
        if tick % 10 == 0 then
            self:setNextPush()
            self:syncBoard()
        end
        self:updateDummy(dt, tick)
        return
    end

    if self.type == "local" then
        if self.isPaused then
            return
        end
        if tick % 10 == 0 then
            self:setNextPush()
            self:syncBoard()
            self.screenRefresh.foreground = true
        end
    elseif type == "stream" then

    end
end

function GAME:getNextPush()
    local qNext = self.history.qLast
    while qNext == self.history.qLast do
        qNext = math.random(1, 4)
    end
--[[
    if self.player.attackInProgress then
        while qNext == self.history.qLast or qNext == self.player.gr do
            qNext = math.random(1, 4)
        end
    else
        while qNext == self.history.qLast do
            qNext = math.random(1, 4)
        end
    end
]]

    local sNext
    if inrange(self.history[qNext].sLast, 1, 4) then
        if math.random(0, 1000) > 750 then
            sNext = self.history[qNext].sLast
        else
            if math.random(0, 1000) > 1000 then
                sNext = math.random(5, 7)
            else
                sNext = self.history[qNext].sLast
                while sNext == self.history[qNext].sLast do
                    sNext = math.random(1, 4)
                end
            end
        end
    else
        sNext = math.random(1, 4)
    end

    local xNext = self.history[qNext].xLast
    local yNext = self.history[qNext].yLast
    if math.random(0, 1000) > 250 then
        if xNext then
            while xNext == self.history[qNext].xLast do
                xNext = math.random(0, 3)
            end
        end
        if yNext then
            while yNext == self.history[qNext].yLast do
                yNext = math.random(0, 3)
            end
        end
    end

    return qNext, xNext, yNext, sNext
end

function GAME:setNextPush()
    local qNext, xNext, yNext, sNext = self:getNextPush()

    self.history.qLast = qNext
    self.history[qNext].xNext = xNext
    self.history[qNext].yLast = yNext
    self.history[qNext].sLast = sNext

    if qNext == 1 then
        for x = 6, 1, -1 do
            local this =  self.board[getIndex(x, yNext + 7)]
            if this ~= 0 then
                self.board[getIndex(x + 1, yNext + 7)] = this
                if x + 1 > 6 then
                    self:gameOver()
                end
            end
        end
        self.board[getIndex(1, yNext + 7)] = sNext
    elseif qNext == 2 then
        for y = 6, 1, -1 do
            local this =  self.board[getIndex(xNext + 7, y)]
            if this ~= 0 then
                self.board[getIndex(xNext + 7, y + 1)] = this
                if y + 1 > 6 then
                    self:gameOver()
                end
            end
        end
        self.board[getIndex(xNext + 7, 1)] = sNext
    elseif qNext == 3 then
        for x = 11, 16 do
            local this =  self.board[getIndex(x, yNext + 7)]
            if this ~= 0 then
                self.board[getIndex(x - 1, yNext + 7)] = this
                if x - 1 < 11 then
                    self:gameOver()
                end
            end
        end
        self.board[getIndex(16, yNext + 7)] = sNext
    elseif qNext == 4 then
        for y = 11, 16 do
            local this =  self.board[getIndex(xNext + 7, y)]
            if this ~= 0 then
                self.board[getIndex(xNext + 7, y - 1)] = this
                if y - 1 < 11 then
                    self:gameOver()
                end
            end
        end
        self.board[getIndex(xNext + 7, 16)] = sNext
    end
end

---------------------------------------------------------------
function GAME:onQuit()
    if not self.gameover then
        if self.type == "local" then
            self:syncBoard()
            net.start("endgame")
            net.send()
        elseif self.type == "stream" and self.streamerEntity then
            net.start("endstream")
            net.writeEntity(self.streamerEntity)
            net.send()
        end
    end
    self.gameover = nil
    self.type = nil
    self.streamerEntity = nil
    self.streamerName = nil
    self.isPaused = false
    self.focus = false
end


---------------------------------------------------------------
function GAME:gameOver()
    self.gameover = true
    if self.isDummy then
        self:onQuit()
        self:syncBoard()
        net.start("endgame")
        net.send()
    else
        self:onKey(nil, "pause")
        if self.type == "local" then
            self:syncBoard()
            net.start("endgame")
            net.send()
        end
    end
end


---------------------------------------------------------------
function GAME:streamGame(ply)
    self:initialize()

    self.type = "stream"
    self.isPaused = false
    self.scorenumber = 0
    self.player = {
        x = 7,
        y = 7,
        direction = 1,
        color = 1,
        matrix = Matrix(),
        pos = Vector(),
    }
    self.player.pos.x = self.player.x*32
    self.player.pos.y = self.player.y*32
    self.player.matrix:setTranslation(self.player.pos)

    self.board = {}
    for n = 1, 256 do
        self.board[n] = 0
    end

    self.streamerEntity = ply
    self.streamerName = ply:getName()

    self.focus = true
end


---------------------------------------------------------------
function GAME:localGame()
    self:initialize()

    self.type = "local"
    self.isPaused = false
    self.scorenumber = 0
    self.player = {
        x = math.random(7, 10),
        y = math.random(7, 10),
        direction = math.random(1, 4),
        color = math.random(1, 4),
        matrix = Matrix(),
        pos = Vector(),
    }
    self.player.pos.x = self.player.x*32
    self.player.pos.y = self.player.y*32
    self.player.matrix:setTranslation(self.player.pos)

    self.history = {
        {
            yLast = math.random(0, 3),
            sLast = math.random(1, 4),
        },
        {
            xLast = math.random(0, 3),
            sLast = math.random(1, 4),
        },
        {
            yLast = math.random(0, 3),
            sLast = math.random(1, 4),
        },
        {
            xLast = math.random(0, 3),
            sLast = math.random(1, 4),
        },
        qLast = math.random(1, 4)
    }

    self.board = {}
    for n = 1, 256 do
        self.board[n] = 0
    end

    self.focus = true
end


---------------------------------------------------------------
local clear = Color(0, 0, 0, 0)
function GAME:onRender()
    if self.screenRefresh.background then
        self.screenRefresh.background = false
        render.selectRenderTarget("backgroundRT")
        render.clear(clear, true)
        self:drawBackground()
        render.selectRenderTarget()
    end
    if self.screenRefresh.foreground then
        self.screenRefresh.foreground = false
        render.selectRenderTarget("foregroundRT")
        render.clear(clear, true)
        self:drawForeground()
        render.selectRenderTarget()
    end
    if self.isPaused then
        render.setRGBA(103, 103, 103, 100)
        for i = 0, 6 do
            local sign = (i % 2 == 0 and -i or i)
            render.setRenderTargetTexture("backgroundRT")
            render.drawTexturedRect(sign, sign, 1024, 1024)
            render.setRenderTargetTexture("foregroundRT")
            render.drawTexturedRect(sign, sign, 1024, 1024)
        end
    else
        render.setRGBA(255, 255, 255, 255)
        render.setRenderTargetTexture("backgroundRT")
        render.drawTexturedRect(0, 0, 1024, 1024)
        render.setRenderTargetTexture("foregroundRT")
        render.drawTexturedRect(0, 0, 1024, 1024)
    end
end


---------------------------------------------------------------
local map = {
    9, 9, 9, 9, 9, 9, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3,
    1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3,
    1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3,
    1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0,
}

local key = {
    [1] = Color(200, 200, 200),
    [2] = Color(225, 225, 225),
    [3] = Color(200, 200, 200),
    [4] = Color(225, 225, 225),
    [5] = Color(127, 127, 127),
}

function GAME:drawBackground()
    render.setMaterial(self.spritesheet)
    for n = 1, 256 do
        local x = getX(n)
        local y = getY(n)

        if map[n] ~= 0 and map[n] ~= 9 then
            local sprite = self.sprites["border"]
            render.setRGBA(45, 45, 45, 255)
            render.drawTexturedRectUVFast(x*32 - 32, y*32 - 32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)

            local sprite = self.sprites["background"]
            render.setColor(key[map[n]])
            render.drawTexturedRectUVFast(x*32 - 32, y*32 - 32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
        else
            local sprite = self.sprites["background"]
            local rgb = (x + y) % 2 == 0 and 50 or 55
            render.setRGBA(rgb,rgb,rgb,255)
            render.drawTexturedRectUVFast(x*32 - 32, y*32 - 32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)

            if map[n] ~= 9 then
                local sprite = self.sprites["dot"]
                render.setRGBA(rgb,rgb,rgb,255)
                render.drawTexturedRectUVFast(x*32 - 32, y*32 - 32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
            end
        end
    end
    if self.type == "stream" then
        render.setFont("Default")
        render.setRGBA(255, 0, 0, 255)
        render.drawText(0, 512 - 32, string.format("You are watching: %s", self.streamerName))
    end
end


---------------------------------------------------------------
function GAME:drawForeground()
    render.setMaterial(self.spritesheet)
    render.setRGBA(255, 255, 255, 255)

    for n = 1, 256 do
        if self.board[n] ~= 0 then
            local x = getX(n)
            local y = getY(n)
            local sprite = self.sprites[self.shapes[self.board[n]]]
            render.drawTexturedRectUVFast(x*32 - 32, y*32 - 32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
        end
    end

    local sprite = self.sprites[self.playerColors[self.player.color][self.player.direction]]
    render.pushMatrix(self.player.matrix)
    render.drawTexturedRectUVFast(-32, -32, 32, 32, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
    render.popMatrix()
end


---------------------------------------------------------------
function GAME:onKey(keyCode, keyName)
    if not self.focus then
        return
    end
    if self.isPaused then
        return
    end
    if keyName == "pause" then
        self.isPaused = true
        MENU.focus = true
        MENU.state = "paused"
        MENU.option = self.gameover and 1 or 0
        MENU:resetFlash()
        return
    end
    if self.type ~= "local" then
        return
    end
    if keyName == "up" then
        if self.player.direction == 2 then
            self:movePlayer(0, -1)
            return
        end
        self:turnPlayer(2)
        return
    elseif keyName == "down" then
        if self.player.direction == 4 then
            self:movePlayer(0, 1)
            return
        end
        self:turnPlayer(4)
        return
    elseif keyName == "left" then
        if self.player.direction == 1 then
            self:movePlayer(-1, 0)
            return
        end
        self:turnPlayer(1)
        return
    elseif keyName == "right" then
        if self.player.direction == 3 then
            self:movePlayer(1, 0)
            return
        end
        self:turnPlayer(3)
        return
    end
end


---------------------------------------------------------------
function GAME:setPlayerPos(x, y)
    self.player.x = x
    self.player.y = y
    self.player.pos.x = x*32
    self.player.pos.y = y*32
    self.player.matrix:setTranslation(self.player.pos)
    self.screenRefresh.foreground = true
    if self.type == "local" then
        self:syncPosition()
    end
end

function GAME:movePlayer(x, y)
    local x = math.clamp(self.player.x + x, 7, 10)
    local y = math.clamp(self.player.y + y, 7, 10)
    if self.player.x ~= x or self.player.y ~= y then
        self:setPlayerPos(x, y)
    end
end


---------------------------------------------------------------
function GAME:setPlayerDirection(direction)
    self.player.direction = direction
    self.screenRefresh.foreground = true
    if self.type == "local" then
        self:syncDirection()
    end
end

function GAME:turnPlayer(direction)
    local direction = math.clamp(direction, 1, 4)
    if self.player.direction  ~= direction then
        self:setPlayerDirection(direction)
    end
end


---------------------------------------------------------------
---- GAME MENU
function MENU:initialize()
    self.gameslist = {}
    self.isInitialized = true
    self.flashtime = timer.curtime()
    self.ticktock = true
    self.option = 0
    self.refresh = true
    self.state = "main"
end


---------------------------------------------------------------
function MENU:think()
    if not self.isInitialized then
        self:initialize()
        return
    end
    if not self.focus then
        return
    end
    if self.onThink then self:onThink() end
end


---------------------------------------------------------------
function MENU:render()
    if not self.isInitialized then
        self:initialize()
        return
    end
    if not self.focus then
        return
    end
    if self.onRender then self:onRender() end
end


---------------------------------------------------------------
local clear = Color(0, 0, 0, 0)
function MENU:onRender()
    if self.refresh then
        self.refresh = false
        render.selectRenderTarget("menuRT")
        render.clear(clear, true)
        self:draw()
        render.selectRenderTarget()
    end
    render.setRGBA(255, 255, 255, 255)
    render.setRenderTargetTexture("menuRT")
    render.drawTexturedRect(0, 0, 1024, 1024)
end


---------------------------------------------------------------
function MENU:onThink()
    if timer.curtime() - self.flashtime > 0.5 then
        self.flashtime = timer.curtime()
        if self.ticktock then
            self.ticktock = false
        else
            self.ticktock = true
        end
        self.refresh = true
    end
end


---------------------------------------------------------------
function MENU:resetFlash()
    self.ticktock = false
    self.flashtime = timer.curtime()
    self.refresh = true
end


---------------------------------------------------------------
local color1 = Color(255, 255, 255, 255)
local color2 = Color(255, 255, 0, 255)
local color3 = Color(100, 100, 100, 255)

local font1 = render.createFont("Akbar", 32, 32, false, false, true, false, false, false)
local font2 = render.createFont("Akbar", 84, 32, false, false, true, false, false, false)
local font3 = render.createFont("Akbar", 20, 32, false, false, true, false, false, false)

local controlStr = "Menu Controls\n    select - ARROW KEYS\n    confirm - SHIFT\nGameControls\n    move - ARROW KEYS\n    attack - SHIFT\n    pause - ALT"

local anim = {
    x = 0,
    y = 0,
    r = 3,
    c = 1,
    incX = 1,
    incY = 1,
}

function anim:render()
    self.x = self.x + self.incX
    if self.incX == 1 and self.x > 3 then
        self.incX = -1
        self.x = self.x + self.incX
        self.r = 1
        self.c = self.c + 1
        if self.c > 4 then self.c = 1 end

        self.y = self.y + self.incY
        if self.y > 3 or self.y < 0 then
            self.incY = -self.incY
            self.y = self.y + self.incY
        end
    end
    if self.incX == -1 and self.x < 0 then
        self.incX = 1
        self.x = self.x + self.incX
        self.r = 3
        self.c = self.c + 1
        if self.c > 4 then self.c = 1 end

        self.y = self.y + self.incY
        if self.y > 3 or self.y < 0 then
            self.incY = -self.incY
            self.y = self.y + self.incY
        end
    end

    render.setMaterial(GAME.spritesheet)
    for y = 0, 3 do
        for x = 0, 3 do
            local index = x + y*4
            local alpha = 150
            if index == 5 or index == 6 or index == 9 or index == 10 or index == 13 or index == 14 then
                alpha = 75
            end
            local sprite = GAME.sprites["border"]
            render.setRGBA(50, 50, 50, alpha)
            render.drawTexturedRectUVFast(x*128, y*128, 128, 128, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
            local sprite = GAME.sprites["background"]
            render.setRGBA(150, 150, 150, alpha)
            render.drawTexturedRectUVFast(x*128, y*128, 128, 128, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
        end
    end

    local sprite = GAME.sprites[GAME.shapes[math.clamp((self.c + 1) % 5, 1, 4)]]
    render.drawTexturedRectUVFast((self.incX == 1 and 3 or 0)*128, self.y*128, 128, 128, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)

    local index = self.x + self.y*4
    local alpha = 150
    if index == 5 or index == 6 or index == 9 or index == 10 or index == 13 or index == 14 then
        alpha = 50
    end

    local sprite = GAME.sprites[GAME.playerColors[self.c][self.r]]
    render.setRGBA(255, 255, 255, alpha)
    render.drawTexturedRectUVFast(self.x*128, self.y*128, 128, 128, sprite.u0, sprite.v0, sprite.u1, sprite.v1, true)
end

local titlem = Matrix()
titlem:setAngles(Angle(0, -22.5, 0))
titlem:setTranslation(Vector(256 - 24, 28, 0))

function MENU:draw()
    if self.state == "main" then
        anim:render()

        render.setFont(font2)
        render.setRGBA(125, 255, 0, 255)
        render.pushMatrix(titlem)
        render.drawText(0, 0, "SLIME\n\tTIME!", 1)
        render.popMatrix()

        render.setFont(font1)
        local color = self.ticktock and color1 or color2
        render.setColor(self.option == 0 and color or color1)
        render.drawText(256, 256 - 16, "NEW GAME", 1)
        render.setColor(self.option == 1 and color or color1)
        render.drawText(256, 256 + 16, string.format("SPECTATE (%d)", #self.gameslist), 1)
        render.setRGBA(255, 125, 0, 255)
        render.setFont(font3)
        render.drawText(256 - 53, 256 + 84, controlStr)
        return
    elseif self.state == "spectate" then
        render.setFont(font1)
        local color = self.ticktock and color1 or color2
        local y = 32
        for i, ply in ipairs(self.gameslist) do
            if not isValid(ply) then
                table.remove(self.gameslist, i)
                continue
            end
            render.setColor(self.option == i and color or color1)
            render.drawText(256, y, ply:getName(), 1)
            y = y + 32
        end
        render.setColor(self.option == 0 and color or color1)
        render.drawText(256, 512 - 32, "MAIN MENU", 1)
        return
    elseif self.state == "paused" then
        if GAME.gameover then
            render.setFont(font2)
            render.setColor(color1)
            render.drawText(256, 32, "GAME OVER!", 1)
        end
        render.setFont(font1)
        local color = self.ticktock and color1 or color2
        render.setColor(GAME.gameover and color3 or (self.option == 0 and color or color1))
        render.drawText(256, 256 - 32, "RESUME", 1)
        render.setColor(self.option == 1 and color or color1)
        render.drawText(256, 256, "QUIT", 1)
    end
end


---------------------------------------------------------------
function MENU:onNewgame()
    net.start("newgame")
    net.send()
    GAME:localGame()
    self.focus = false
end

function MENU:onSpectate()
    if not self.gameslist[self.option] then
        return
    end
    net.start("newstream")
    net.writeEntity(self.gameslist[self.option])
    net.send()
end

function MENU:onResume()
    self.focus = false
    GAME.isPaused = false
end

function MENU:onQuit()
    GAME:onQuit()
    self.state = "main"
    self.option = 0
    self:resetFlash()
end


---------------------------------------------------------------
function MENU:onKey(keyCode, keyName)
    if not self.focus then
        return
    end
    if self.state == "main" then
        if keyName == "up" then
            self.option = self.option - 1
            if self.option < 0 then
                self.option = 1
            end
            self:resetFlash()
            return
        elseif keyName == "down" then
            self.option = self.option + 1
            if self.option > 1 then
                self.option = 0
            end
            self:resetFlash()
            return
        elseif keyName == "enter" then
            if self.option == 0 then
                self:onNewgame()
                return
            elseif self.option == 1 then
                self.state = "spectate"
                self.option = 0
                self:resetFlash()
                return
            end
        end
        return
    elseif self.state == "spectate" then
        if keyName == "up" then
            self.option = self.option - 1
            if self.option < 0 then
                self.option = #self.gameslist
            end
            self:resetFlash()
            return
        elseif keyName == "down" then
            self.option = self.option + 1
            if self.option > #self.gameslist then
                self.option = 0
            end
            self:resetFlash()
            return
        elseif keyName == "enter" then
            if self.option == 0 then
                self.state = "main"
                self.option = 0
                self:resetFlash()
                return
            else
                self:onSpectate()
                return
            end
        end
        return
    elseif self.state == "paused" then
        if keyName == "up" then
            if GAME.gameover then
                return
            end
            self.option = self.option - 1
            if self.option < 0 then
                self.option = 1
            end
            self:resetFlash()
            return
        elseif keyName == "down" then
            if GAME.gameover then
                return
            end
            self.option = self.option + 1
            if self.option > 1 then
                self.option = 0
            end
            self:resetFlash()
            return
        elseif keyName == "enter" then
            if self.option == 0 then
                self:onResume()
                return
            elseif self.option == 1 then
                self:onQuit()
                return
            end
        end
        return
    end
end


---------------------------------------------------------------
---- HOOKS
MENU.refresh = true
MENU.focus = true
MENU:initialize()

hook.add("render", "", function()
    if not GAME.spritesheet.isLoaded then
        return
    end

    cursor:update()
    GAME:render()
    MENU:render()
end)

hook.add("think", "", function()
    GAME:think()
    MENU:think()
end)

local menuKeys = {
    [79] = "enter",
    [80] = "enter",
    [89] = "left",
    [91] = "right",
    [88] = "up",
    [90] = "down",
}

hook.add("inputPressed", "menuKeys", function(keyCode)
    if not cursor.onScreen then return end
    if not menuKeys[keyCode] then
        return
    end
    MENU:onKey(keyCode, menuKeys[keyCode])
end)

local gameKeys = {
    [79] = "enter",
    [80] = "enter",
    [81] = "pause",
    [89] = "left",
    [91] = "right",
    [88] = "up",
    [90] = "down",
}

hook.add("inputPressed", "gameKeys", function(keyCode)
    if not cursor.onScreen then return end
    if not gameKeys[keyCode] then
        return
    end
    GAME:onKey(keyCode, gameKeys[keyCode])
end)


---------------------------------------------------------------
---- CLIENTSIDE NETWORKING
function GAME:syncDirection()
    if not self.player or not self.player.direction then
        return
    end
    net.start("syncDir")
    net.writeUInt(self.player.direction, 8)
    net.send()
end

function GAME:syncPosition()
    if not self.player or not self.player.x or not self.player.y then
        return
    end
    net.start("syncPos")
    net.writeUInt(self.player.x, 8)
    net.writeUInt(self.player.y, 8)
    net.send()
end

function GAME:syncColor()
    if not self.player or not self.player.color then
        return
    end
    net.start("syncCol")
    net.writeUInt(self.player.color, 8)
    net.send()
end

function GAME:syncScore()
    if not self.scorenumber then
        return
    end
    net.start("syncScore")
    net.writeUInt(self.scorenumber, 32)
    net.send()
end

function GAME:syncBoard()
    if not self.board then
        return
    end
    net.start("syncBoard")
    net.writeString(table.concat(self.board))
    net.send()
end

function GAME:syncAttack()
    if not self.board then
        return
    end
    net.start("syncAttack")
    net.writeString(table.concat(self.board))
    net.send()
end

net.receive("syncGamesList", function()
    local count = net.readUInt(8)
    if not count then
        return
    end
    MENU.gameslist = {}
    for i = 1, count do
        local ply = net.readEntity()
        if ply and ply ~= player() then
            table.insert(MENU.gameslist, ply)
        end
    end
end)

net.receive("syncDir", function(len, ply)
    if not GAME.player then
        return
    end
    local direction = net.readUInt(8)
    if not direction then
        return
    end
    GAME.player.direction = direction
    GAME.screenRefresh.foreground = true
end)

net.receive("syncPos", function(len, ply)
    if not GAME.player then
        return
    end
    local x = net.readUInt(8)
    local y = net.readUInt(8)
    if not x or not y then
        return
    end
    GAME.player.x = x
    GAME.player.y = y
    GAME.player.pos.x = GAME.player.x*32
    GAME.player.pos.y = GAME.player.y*32
    GAME.player.matrix:setTranslation(GAME.player.pos)
    GAME.screenRefresh.foreground = true
end)

net.receive("syncCol", function(len, ply)
    if not GAME.player then
        return
    end
    local color = net.readUInt(8)
    if not color then
        return
    end
    GAME.player.color = color
    GAME.screenRefresh.foreground = true
end)

net.receive("syncScore", function(len, ply)
    local score = net.readUInt(32)
    if not score then
        return
    end
    GAME.scorenumber = score
end)

net.receive("syncBoard", function(len, ply)
    local board = net.readString()
    if not board or #board ~= 256 then
        return
    end
    for n = 1, 256 do
        GAME.board[n] = tonumber(board[n])
    end
    GAME.screenRefresh.foreground = true
end)

net.receive("syncAttack", function(len, ply)
    local board = net.readString()
    if not board or #board ~= 256 then
        return
    end
    for n = 1, 256 do
        GAME.board[n] = tonumber(board[n])
    end
    GAME:queuePlayerAttack()
end)

net.receive("newstream",function()
    local ply = net.readEntity()
    if not ply then
        return
    end
    GAME:streamGame(ply)
    MENU.focus = false
end)

net.receive("endgame",function()
    GAME:gameOver()
end)


---------------------------------------------------------------
---- textures
GAME.spritesheet = material.create("UnlitGeneric")
GAME.spritesheet.isLoaded = false
GAME.spritesheet:setTextureURL("$basetexture", "https://raw.githubusercontent.com/shadowscion/starfall/master/slimes.png", nil,
function(mat)
    timer.simple(1, function()
        mat.isLoaded = true
    end)
end)

GAME.sprites = {
    ["background"] = { x = 0, y = 0, w = 32, h = 32 },
    ["bomb1"] = { x = 32, y = 0, w = 32, h = 32 },
    ["bomb2"] = { x = 64, y = 0, w = 32, h = 32 },
    ["border"] = { x = 96, y = 0, w = 32, h = 32 },
    ["dot"] = { x = 128, y = 0, w = 32, h = 32 },
    ["key_alt"] = { x = 160, y = 0, w = 64, h = 32 },
    ["key_down"] = { x = 0, y = 32, w = 32, h = 32 },
    ["key_left"] = { x = 32, y = 32, w = 32, h = 32 },
    ["key_right"] = { x = 64, y = 32, w = 32, h = 32 },
    ["key_shift"] = { x = 96, y = 32, w = 64, h = 32 },
    ["key_up"] = { x = 160, y = 32, w = 32, h = 32 },
    ["marker"] = { x = 192, y = 32, w = 32, h = 32 },
    ["oneup"] = { x = 0, y = 64, w = 32, h = 32 },
    ["s1d"] = { x = 32, y = 64, w = 32, h = 32 },
    ["s1e1"] = { x = 64, y = 64, w = 32, h = 32 },
    ["s1l"] = { x = 96, y = 64, w = 32, h = 32 },
    ["s1r"] = { x = 128, y = 64, w = 32, h = 32 },
    ["s1t1"] = { x = 160, y = 64, w = 32, h = 32 },
    ["s1t2"] = { x = 192, y = 64, w = 32, h = 32 },
    ["s1t3"] = { x = 0, y = 96, w = 32, h = 32 },
    ["s1t4"] = { x = 32, y = 96, w = 32, h = 32 },
    ["s1u"] = { x = 64, y = 96, w = 32, h = 32 },
    ["s2d"] = { x = 96, y = 96, w = 32, h = 32 },
    ["s2e1"] = { x = 128, y = 96, w = 32, h = 32 },
    ["s2l"] = { x = 160, y = 96, w = 32, h = 32 },
    ["s2r"] = { x = 192, y = 96, w = 32, h = 32 },
    ["s2t1"] = { x = 0, y = 128, w = 32, h = 32 },
    ["s2t2"] = { x = 32, y = 128, w = 32, h = 32 },
    ["s2t3"] = { x = 64, y = 128, w = 32, h = 32 },
    ["s2t4"] = { x = 96, y = 128, w = 32, h = 32 },
    ["s2u"] = { x = 128, y = 128, w = 32, h = 32 },
    ["s3d"] = { x = 160, y = 128, w = 32, h = 32 },
    ["s3e1"] = { x = 192, y = 128, w = 32, h = 32 },
    ["s3l"] = { x = 0, y = 160, w = 32, h = 32 },
    ["s3r"] = { x = 32, y = 160, w = 32, h = 32 },
    ["s3t1"] = { x = 64, y = 160, w = 32, h = 32 },
    ["s3t2"] = { x = 96, y = 160, w = 32, h = 32 },
    ["s3t3"] = { x = 128, y = 160, w = 32, h = 32 },
    ["s3t4"] = { x = 160, y = 160, w = 32, h = 32 },
    ["s3u"] = { x = 192, y = 160, w = 32, h = 32 },
    ["s4d"] = { x = 0, y = 192, w = 32, h = 32 },
    ["s4e1"] = { x = 32, y = 192, w = 32, h = 32 },
    ["s4l"] = { x = 64, y = 192, w = 32, h = 32 },
    ["s4r"] = { x = 96, y = 192, w = 32, h = 32 },
    ["s4t1"] = { x = 128, y = 192, w = 32, h = 32 },
    ["s4t2"] = { x = 160, y = 192, w = 32, h = 32 },
    ["s4t3"] = { x = 192, y = 192, w = 32, h = 32 },
    ["s4t4"] = { x = 224, y = 0, w = 32, h = 32 },
    ["s4u"] = { x = 224, y = 32, w = 32, h = 32 },
}

for k, v in pairs(GAME.sprites) do
    v.u0 = v.x/1024
    v.v0 = v.y/1024
    v.u1 = (v.x + v.w)/1024
    v.v1 = (v.y + v.h)/1024
end

GAME.shapes = {
    [1] = "s1e1",
    [2] = "s2e1",
    [3] = "s3e1",
    [4] = "s4e1",
}

GAME.playerColors = {
    [1] = { "s1l", "s1u", "s1r", "s1d" },
    [2] = { "s2l", "s2u", "s2r", "s2d" },
    [3] = { "s3l", "s3u", "s3r", "s3d" },
    [4] = { "s4l", "s4u", "s4r", "s4d" },
}

for i, col in ipairs(GAME.playerColors) do
    for _, sp in ipairs(col) do
        if not GAME.sprites[sp] then print(sp) end
    end
end


---------------------------------------------------------------
---- testing
local function dummyGameStart()
    if player() == owner() then return end
    MENU:onNewgame()
    GAME.isDummy = true
end

local function dummyGameStop()
    if player() == owner() then return end
    MENU:onQuit()
end

dummyGameStart()

function GAME:updateDummy(dt, tick)
    if net.getBytesLeft() < 1000 then return end
    if math.random(0, 100) > 95 then
        local keys = { "left", "up", "right", "down" }
        if math.random(1, 4) >= 2 then
            self:onKey(nil, keys[math.random(1, 4)])
        else
            self:onKey(nil, keys[self.player.direction])
        end
    end
end
